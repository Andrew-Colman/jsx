<html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>JSX | XML-like syntax extension to ECMAScript</title><meta name="viewport" content="width=device-width"><meta property="og:title" content="JSX | XML-like syntax extension to ECMAScript"><meta property="og:type" content="website"><meta property="og:url" content="http://facebook.github.io/jsx/index.html"><meta property="og:description" content="XML-like syntax extension to ECMAScript"><link rel="stylesheet" href="/jsx/css/jsx.css"><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/jsx/">JSX</a><ul class="nav-site"><li><a href="http://github.com/facebook/jsx" class="">github</a></li></ul></div></div><div class="hero"><div class="wrap"><div class="text"><strong>JSX</strong></div><div class="minitext">XML-like syntax extension to ECMAScript</div></div></div><section class="content wrap"><section class="home-section"><div><p>JSX is a XML-like syntax extension to ECMAScript without any defined semantics. It&#x27;s NOT intended to be implemented by engines or browsers. It&#x27;s intended to be used by various preprocessors (transpilers) to transform these tokens into standard ECMAScript.</p><h2><a class="anchor" name="rationale"></a>Rationale <a class="hash-link" href="#rationale">#</a></h2><p>The purpose of this specification is to define a concise and familiar syntax for defining tree structures with attributes. A generic but well defined syntax enables a community of independent parsers and syntax highlighters to conform to a single specification.</p><p>Embedding a new syntax in an existing language is a risky venture. Other syntax implementors or the existing language may introduce another incompatible syntax extension.</p><p>Through a stand-alone specification, we make it easier for implementors of other syntax extensions to consider JSX when designing their own syntax. This will hopefully allow various new syntax extensions to co-exist.</p><p>It is our intention to claim minimal syntactic real estate while keeping the syntax concise and familiar. That way we leave the door open for other extensions.</p><h2><a class="anchor" name="syntax"></a>Syntax <a class="hash-link" href="#syntax">#</a></h2><p><em>JSX extends the PrimaryExpression in the <a href="http://people.mozilla.org/~jorendorff/es6-draft.html" target="_blank">ECMAScript 6th Edition (ECMA-262)</a> grammar.</em></p><p>PrimaryExpression :</p><ul><li>JSXElement</li></ul><p><strong>Elements</strong></p><p>JSXElement :</p><ul><li><p>JSXSelfClosingElement</p></li><li><p>JSXOpeningElement JSXChildren<sub>opt</sub> JSXClosingElement</p></li></ul><p>JSXSelfClosingElement :</p><ul><li><code>&lt;</code> JSXElementName JSXAttributes<sub>opt</sub> JSXWhitespace<sub>opt</sub> <code>/</code> <code>&gt;</code></li></ul><p>JSXOpeningElement :</p><ul><li><code>&lt;</code> JSXElementName JSXAttributes<sub>opt</sub> JSXWhitespace<sub>opt</sub> <code>&gt;</code></li></ul><p>JSXClosingElement :</p><ul><li><code>&lt;</code> <code>/</code> JSXElementName JSXWhitespace<sub>opt</sub> <code>&gt;</code></li></ul><p>JSXElementName :</p><ul><li>JSXIdentifier</li><li>JSXNamedspacedName</li><li>JSXMemberExpression</li></ul><p>JSXIdentifier :</p><ul><li>JSXIdentifierStart</li><li>JSXIdentifier JSXIdentifierPart</li></ul><p>JSXIdentifierStart :</p><ul><li>IdentifierStart <strong>but not <code>\</code> UnicodeEscapeSequence</strong></li></ul><p>JSXIdentifierPart :</p><ul><li>IdentifierPart <strong>but not <code>\</code> UnicodeEscapeSequence</strong></li><li><code>-</code></li></ul><p>JSXNamespacedName :</p><ul><li>JSXIdentifier <code>:</code> JSXIdentifier</li></ul><p>JSXMemberExpression :</p><ul><li>JSXMemberExpression <code>.</code> JSXIdentifier</li></ul><p><strong>Attributes</strong></p><p>JSXAttributes :</p><ul><li>JSXSpreadAttribute JSXAttributes<sub>opt</sub></li><li>JSXAttribute JSXAttributes<sub>opt</sub></li></ul><p>JSXSpreadAttribute :</p><ul><li>JSXWhitespace <code>{</code> <code>...</code> AssignmentExpression <code>}</code></li></ul><p>JSXAttribute :</p><ul><li>JSXWhitespace JSXAttributeName JSXWhitespace<sub>opt</sub> <code>=</code> JSXWhitespace<sub>opt</sub> JSXAttributeValue</li></ul><p>JSXAttributeName :</p><ul><li>JSXIdentifier</li><li>JSXNamespacedName</li></ul><p>JSXAttributeValue :</p><ul><li><code>&quot;</code> JSXDoubleStringCharacters<sub>opt</sub> <code>&quot;</code></li><li><code>&#x27;</code> JSXSingleStringCharacters<sub>opt</sub> <code>&#x27;</code></li><li><code>{</code> JSXWhitespace <code>}</code></li><li><code>{</code> AssignmentExpression <code>}</code></li></ul><p>JSXDoubleStringCharacters :</p><ul><li>JSXDoubleStringCharacter JSXDoubleStringCharacters<sub>opt</sub></li></ul><p>JSXDoubleStringCharacter :</p><ul><li>SourceCharacter <strong>but not <code>&quot;</code></strong></li></ul><p>JSXSingleStringCharacters :</p><ul><li>JSXSingleStringCharacter JSXSingleStringCharacters<sub>opt</sub></li></ul><p>JSXSingleStringCharacter :</p><ul><li>SourceCharacter <strong>but not <code>&#x27;</code></strong></li></ul><p><strong>Children</strong></p><p>JSXChildren :</p><ul><li>JSXChild JSXChildren<sub>opt</sub></li></ul><p>JSXChild :</p><ul><li>JSXText JSXChildren<sub>opt</sub></li><li>JSXElement JSXChildren<sub>opt</sub></li><li><code>{</code> JSXWhitespace<sub>opt</sub> <code>}</code></li><li><code>{</code> AssignmentExpression <code>}</code></li></ul><p>JSXText :</p><ul><li>JSXTextCharacter JSXText<sub>opt</sub></li></ul><p>JSXTextCharacter :</p><ul><li>SourceCharacter <strong>but not one of <code>{</code> or <code>&lt;</code></strong></li></ul><p><strong>Whitespace and Comments</strong></p><p><em>JSX treats comments as whitespace where they are allowed.</em></p><p>JSXWhitespace :</p><ul><li>JSXWhitespacePart JSXWhitespace<sub>opt</sub></li></ul><p>JSXWhitespacePart :</p><ul><li>WhiteSpace</li><li>LineTerminator</li><li>Comment</li></ul><h2><a class="anchor" name="parser-implementations"></a>Parser Implementations <a class="hash-link" href="#parser-implementations">#</a></h2><ul><li><a href="https://github.com/RReverser/acorn-jsx" target="_blank">acorn-jsx</a>: A fork of acorn.</li><li><a href="https://github.com/facebook/esprima" target="_blank">esprima-fb</a>: A fork of esprima.</li><li><a href="https://github.com/andreypopp/sweet-jsx" target="_blank">sweet-jsx</a>: A sweet.js macro.</li></ul><h2><a class="anchor" name="transpilers"></a>Transpilers <a class="hash-link" href="#transpilers">#</a></h2><p>These are a set of transpilers that all conform to the JSX syntax but use different semantics on the output:</p><ul><li><a href="https://github.com/vjeux/jsxdom" target="_blank">jsxdom</a>: Create DOM elements using JSX.</li><li><a href="https://github.com/Raynos/mercury-jsx" target="_blank">Mercury JSX</a>: Create virtual-dom VNodes or VText using JSX. </li><li><a href="http://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank">React JSX</a>: Create ReactElements using JSX.</li></ul><h2><a class="anchor" name="why-not-template-literals"></a>Why not Template Literals? <a class="hash-link" href="#why-not-template-literals">#</a></h2><p><a href="http://people.mozilla.org/~jorendorff/es6-draft.html" target="_blank">ECMAScript 6th Edition (ECMA-262)</a> introduces template literals which are intended to be used for embedding DSL in ECMAScript. Why not just use that instead of inventing a syntax that&#x27;s not part of ECMAScript?</p><p>ES6 template literals are a flexible way to embed alternate syntaxes into pure JS code. That said, the syntactical overhead of using template literals in lieu of JSX is significant. Compare:</p><div class="prism language-javascript"><span class="token comment" spellcheck="true">// JSX
</span><span class="token keyword">var</span> box <span class="token operator">=</span>
  &lt;Box<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token function">answerQuestion<span class="token punctuation">(</span></span>&lt;Answer value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>no&lt;<span class="token operator">/</span>Answer<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
  &lt;<span class="token operator">/</span>Box<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// ES6 template literal
</span><span class="token keyword">var</span> box <span class="token operator">=</span> jsx`
  &lt;$<span class="token punctuation">{</span>Box<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    $<span class="token punctuation">{</span><span class="token function">answerQuestion<span class="token punctuation">(</span></span>jsx`&lt;$<span class="token punctuation">{</span>Answer<span class="token punctuation">}</span> value<span class="token operator">=</span>$<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>no&lt;<span class="token operator">/</span>$<span class="token punctuation">{</span>Answer<span class="token punctuation">}</span><span class="token operator">&gt;</span>`<span class="token punctuation">)</span><span class="token punctuation">}</span>
  &lt;<span class="token operator">/</span>$<span class="token punctuation">{</span>Box<span class="token punctuation">}</span><span class="token operator">&gt;</span>
`<span class="token punctuation">;</span></div><p>For performance, it also makes sense to use a specialized transform to avoid the runtime cost of parsing the tag strings. The semantics of JSX are defined by the transpiler, which sidesteps the need to perform any parsing at runtime.</p><h2><a class="anchor" name="prior-art"></a>Prior Art <a class="hash-link" href="#prior-art">#</a></h2><p>The JSX syntax was derived from the <a href="http://www.ecma-international.org/publications/standards/Ecma-357.htm" target="_blank">E4X Specification (ECMA-357)</a>. E4X is a deprecated specification with deep reaching semantic meaning. JSX largely overlaps with a tiny subset of the E4X syntax. However, JSX is a stand-alone specification has no relation to the E4X specification.</p></div></section></section><footer class="wrap"><div class="right">© 2014 Facebook Inc.</div></footer></div><div id="fb-root"></div><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-387204-10', 'facebook.github.io');
            ga('send', 'pageview');

            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)
            ){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
          </script></body></html>